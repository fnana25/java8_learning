
问：一条SQL查询语句是如何执行的

问：一条SQL更新语句是如何执行的

问：事务隔离
当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读等问题，所以就产生了隔离级别；
sql的标准隔离级别包括读未提交、读已提交、可重复读，串行化；

隔离的实现：
事务隔离是在存储引擎层实现的，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。
- “读未提交”隔离级别下，直接返回记录上的最新值，没有视图概念；
- “读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的；
- “可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图（mvcc多版本并发控制）；
- “串行化”隔离级别下，直接用加锁的方式来避免并行访问。

索引：
索引的常见模型有哈希表、有序数组和索引树
哈希表适合等值查询的场景；有序数组只适用于读多写少的等值查询和范围查询；索引树读写性能都好``````
innodb索引：
每一个索引在 InnoDB 里面对应一棵 B+ 树，分为主键索引和非主键索引，基于非主键索引的查询需要多扫描一棵主键索引树。
自增主键的好处：
每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂；
主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也越小；
b+树的好处：
B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

回表：
回到主键索引树搜索的过程
覆盖索引：
如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，
不用回表操作，直接返回结果，减少IO磁盘读写读取整行数据。
联合索引：
也可以用到覆盖索引，不再需要回表查整行记录；
索引下推：
MySQL 5.6 引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
最左前缀原则：
联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符，
如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

锁：
全局锁和表锁：
根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁。
全局锁（Flush tables with read lock (FTWRL)）：
顾名思义，全局锁就是对整个数据库实例加锁。
- 全局锁的典型使用场景是，做全库逻辑备份
缺点：在主库备份会导致更新语句阻塞，业务不可用；在从库备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致数据不一致
- 官方自带的逻辑备份工具 mysqldump，当 mysqldump 使用参数–single-transaction 的时候，
导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。
缺点：只适用于支持事务的引擎
- set global readonly=true方式
缺点：该值在某些场景用来判断数据库是否为主从库；如果客户端连接异常，数据库依然保持readonly状态，会导致数据库长时间不可写。
表级锁（lock tables … read/write）/ MDL（metadata lock)
当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。
所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。
如何安全的给小表加字段？
在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，
拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。

问：行锁功过：怎么减少行锁对性能的影响
两阶段协议：
在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。
如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
死锁解决办法：
- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout 来设置（默认50s）。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

问：普通索引和唯一索引，应该怎么选择
查询过程的区别：唯一索引查询到符合条件的数据就不会继续查找了，普通索引会继续查找下一条数据，直到不满足条件。（性能差别微乎其微，因为innoDB读数据是按数据页读取）
更新过程：如果要更新的数据页还没加载到内存中，innoDB会将更新操作缓存到change buffer中，当下次数据加载到内存中时再执行更新操作。
唯一索引需要判断key值是否冲突必须得将数据页读入内存判断，因此不能使用change buffer。
redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。
由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发优先考虑非唯一索引。

问：MySQL为什么有时候会选错索引
优化器会根据分析查询语句的扫描行数，是否使用临时表，是否排序，回表代价等来选择最优索引

问：怎么给字符串字段加索引
直接创建完整索引，这样可能比较占用空间；
创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；
创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。

问：sql语句变慢原因（flash内存页到磁盘）
当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”
触发flash过程的几种情况：
1、redo log 写满了；
2、系统内存不够用；
3、数据库空闲的时候；
4、数据库关闭。

问：为什么表数据删掉一般表文件大小不变
一个 InnoDB 表包含两部分，即：表结构定义和数据。在 MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里。
而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。
数据的删除流程：
InnoDB 的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，数据页就可以复用了。
delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的
重建表可以收缩空间
重建表的两种方式：
alter table A engine=InnoDB
Online DDL
Online DDL 的方式是可以考虑在业务低峰期使用的，而 MySQL 5.5 及之前的版本，这个命令是会阻塞 DML 的，这个你需要特别小心

问：count(*)为什么这么慢
myIsam记录了表的总行数，innodb需要一行一行读取计数（会选择数据量最小的索引树读取）
避免使用count(*)的方法：
用缓存系统保存计数；缺点：两个不同存储构成的系统，不支持分布式事务，无法拿到精确一致的视图
在数据库保存计数。可以利用事务解决一致性
count()效率比较：
count(字段)<count(主键 id)<count(1)≈count(*)

问：order by是如何工作的
explain 命令Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。
全字段排序
初始化 sort_buffer，确定放入 name、city、age 这三个字段；
从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；
到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；
从索引 city 取下一个记录的主键 id；
重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；
对 sort_buffer 中的数据按照字段 name 做快速排序；
按照排序结果取前 1000 行返回给客户端。
rowid排序  （如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差）
初始化 sort_buffer，确定放入两个字段，即 name 和 id；
从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；
到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；
从索引 city 取下一个记录的主键 id；
重复步骤 3、4 直到不满足 city='杭州’条件为止，也就是图中的 ID_Y；
对 sort_buffer 中的数据按照字段 name 进行排序；
遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。

MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。

问：为什么这些sql的逻辑相同性能却相差巨大
1、条件字段函数操作
2、隐式类型转换 
3、隐式字符编码转换
结论：对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。

问：为什么我只查一行的语句，也执行这么慢？
第一类：查询长时间不返回
1、等 MDL 锁
2、等 flush
3、等行锁
第二类：查询慢
一致性读，执行undo log ，可以使用lock in share mode，采用当前读模式快速返回。

问：幻读是什么，幻读会导致什么问题？
幻读仅专指“新插入的行”，即使把所有的记录都加上锁，还是阻止不了新插入的记录
如何解决幻读？
行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。
间隙锁在可重复读隔离级别下才有效
间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的

问：MySQL是怎么保证数据不丢的？
只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复
binlog 的写入机制：
事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。
redo log 的写入机制：
InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。

问：MySQL是怎么保证主备一致的？
主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写 binlog。
备库 B 跟主库 A 之间维持了一个长连接。
1、在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。
2、在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。
3、主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。
4、备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。
5、sql_thread 读取中转日志，解析出日志里的命令，并执行。
binlog 的三种格式对比：
statement： binlog 里的是语句原文 可能会导致主备不一致
row：比较占空间
mixed： MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式
用 binlog 来恢复数据的标准做法是，用 mysqlbinlog 工具解析出来，然后把解析结果整个发给 MySQL 执行

问：MySQL是怎么保证高可用的？
正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性。
但是最终一致性是不够的。
主备延迟：
主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产 binlog 的速度要慢。
延迟主要来源：
1、备库所在机器的性能要比主库所在的机器性能差
2、备库的压力大
3、大事务

问：备库为什么会延迟好几个小时？
如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。
采用并行复制策略可以缩小延迟时间
在官方的 5.6 版本之前，MySQL 只支持单线程复制，

问：主库出问题了，从库怎么办？
1、基于位点的主备切换
2、基于 GTID 的主备切换

问：读写分离有哪些坑？
怎么处理过期读问题：
1、强制走主库方案；对于必须要拿到最新结果的请求，强制将其发到主库上，对于可以读到旧数据的请求，才将其发到从库上。
2、sleep 方案；主库更新后，读从库之前先 sleep 一下。
3、判断主备无延迟方案；每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。
4、配合 semi-sync 方案；表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。semi-sync+ 位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。
5、等主库位点方案；
6、等 GTID 方案。

问：如何判断一个数据库是不是出问题了？
1、select 1 
在 InnoDB 中，innodb_thread_concurrency 这个参数的默认值是 0,建议把 innodb_thread_concurrency 设置为 64~128 之间的值。
在线程进入锁等待以后，并发线程的计数会减一，也就是说等行锁（也包括间隙锁）的线程是不算在 innodb_thread_concurrency 里面的。
select 1 语句没有用到innodb所以不准确。
2、查表判断 建立一张表，插入一条语句，定期执行查询语句。不足：更新事务要写 binlog，而一旦 binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。
3、更新判断 建立一张表，插入一条语句，定期执行更新语句。
4、内部统计  MySQL 5.6 版本以后提供的 performance_schema 库，就在 file_summary_by_event_name 表里统计了每次 IO 请求的时间。
推荐方案：优先考虑 update 系统表，然后再配合增加检测 performance_schema 的信息











