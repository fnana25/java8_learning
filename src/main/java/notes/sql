

###事务隔离：
当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读等问题，所以就产生了隔离级别；
sql的标准隔离级别包括读未提交、读已提交、可重复读，串行化；

####隔离的实现：
事务隔离是在存储引擎层实现的，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。
- “可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图（mvcc多版本并发控制）；
- “读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的；
- “读未提交”隔离级别下，直接返回记录上的最新值，没有视图概念；
- “串行化”隔离级别下，直接用加锁的方式来避免并行访问。

###索引：
索引的常见模型有哈希表、有序数组和索引树
哈希表适合等值查询的场景；有序数组适合只适用于读多写少的等值查询和范围查询；索引树读写性能都好``````
####innodb索引：
每一个索引在 InnoDB 里面对应一棵 B+ 树，分为主键索引和非主键索引，基于非主键索引的查询需要多扫描一棵主键索引树。
####自增主键的好处：
每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂；
主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也越小；
####b+树的好处：
B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

####回表：
回到主键索引树搜索的过程
####覆盖索引：
如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，
不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据。
####联合索引：
也可以用到覆盖索引，不再需要回表查整行记录；
####索引下推：
MySQL 5.6 引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
####最左前缀原则：
联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符，
如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

###锁
根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁。
####全局锁（Flush tables with read lock (FTWRL)）：
顾名思义，全局锁就是对整个数据库实例加锁。
- 全局锁的典型使用场景是，做全库逻辑备份
缺点：在主库备份会导致更新语句阻塞，业务不可用；在从库备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致数据不一致

- 官方自带的逻辑备份工具 mysqldump，当 mysqldump 使用参数–single-transaction 的时候，
导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。
缺点：只适用于支持事务的引擎

- set global readonly=true方式
缺点：该值在某些场景用来判断数据库是否为主从库；如果客户端连接异常，数据库依然保持readonly状态，会导致数据库长时间不可写。

####表级锁（lock tables … read/write）/ MDL（metadata lock)
当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。
所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。
如何安全的给小表加字段？
在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，
拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。

####行锁
两阶段协议：
在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。
如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

死锁解决办法：
- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout 来设置（默认50s）。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。












